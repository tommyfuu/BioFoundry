# -*- coding: utf-8 -*-

"""
Author      : Tom Fu
Date        : 2020 Nov 7
FileName    : fastCloningPrimer.py (for the BioFoundry Project at the HMC BioMakerspace)
Description : Find primer pairs for fast cloning
"""
import primer3
from Bio import SeqIO
import pandas as pd
import sys
import copy

from selenium import webdriver
from selenium.webdriver.common.keys import Keys
import os
import time


#################
### TESTCASES ###
#################
primer3pySeq = 'GCTTGCATGCCTGCAGGTCGACTCTAGAGGATCCCCCTACATTTTAGCATCAGTGAGTACAGCATGCTTACTGGAAGAGAGGGTCATGCAACAGATTAGGAGGTAAGTTTGCAAAGGCAGGCTAAGGAGGAGACGCACTGAATGCCATGGTAAGAACTCTGGACATAAAAATATTGGAAGTTGTTGAGCAAGTNAAAAAAATGTTTGGAAGTGTTACTTTAGCAATGGCAAGAATGATAGTATGGAATAGATTGGCAGAATGAAGGCAAAATGATTAGACATATTGCATTAAGGTAAAAAATGATAACTGAAGAATTATGTGCCACACTTATTAATAAGAAAGAATATGTGAACCTTGCAGATGTTTCCCTCTAGTAG'

vectorPlasmid1AddressGB = 'biofoundry-copy-of-pdms123.gb'
vectorPlasmid1AddressFA = 'biofoundry-copy-of-pdms123.fasta'
insertPlasmid1AddressGB = 'biofoundry-copy-of-e-coli-iram-annotated.gb'
insertPlasmid1AddressFA = 'biofoundry-copy-of-e-coli-iram-annotated.fasta'
vectorPlasmidSeq1 = 'TTCGAGCTCGGTACCGGATCCGTCGACCTGCAGCCAAGCTTAATTAGCTGAGCTTGGACTCCTGTTGATAGATCCAGTAATGACCTCAGAACTCCATCTGGATTTGTTCAGAACGCTCGGTTGCCGCCGGGCGTTTTTTATTGGTGAGAATCCAAGCTAGCTTGGCGAGATTTTCAGGAGCTAAGGAAGCTAAAATGGAGAAAAAAATCACTGGATATACCACCGTTGATATATCCCAATGGCATCGTAAAGAACATTTTGAGGCATTTCAGTCAGTTGCTCAATGTACCTATAACCAGACCGTTCAGCTGGATATTACGGCCTTTTTAAAGACCGTAAAGAAAAATAAGCACAAGTTTTATCCGGCCTTTATTCACATTCTTGCCCGCCTGATGAATGCTCATCCGGAATTTCGTATGGCAATGAAAGACGGTGAGCTGGTGATATGGGATAGTGTTCACCCTTGTTACACCGTTTTCCATGAGCAAACTGAAACGTTTTCATCGCTCTGGAGTGAATACCACGACGATTTCCGGCAGTTTCTACACATATATTCGCAAGATGTGGCGTGTTACGGTGAAAACCTGGCCTATTTCCCTAAAGGGTTTATTGAGAATATGTTTTTCGTCTCAGCCAATCCCTGGGTGAGTTTCACCAGTTTTGATTTAAACGTGGCCAATATGGACAACTTCTTCGCCCCCGTTTTCACCATGGGCAAATATTATACGCAAGGCGACAAGGTGCTGATGCCGCTGGCGATTCAGGTTCATCATGCCGTTTGTGATGGCTTCCATGTCGGCAGAATGCTTAATGAATTACAACAGTACTGCGATGAGTGGCAGGGCGGGGCGTAATTTTTTTAAGGCAGTTATTGGTGCCCTTAAACGCCTGGGGTAATGACTCTCTAGCTTGAGGCATCAAATAAAACGAAAGGCTCAGTCGAAAGACTGGGCCTTTCGTTTTATCTGTTGTTTGTCGGTGAACGCTCTCCTGAGTAGGACAAATCCGCCCTCTAGCAGCCCGGGCTGCggccgcTATTTCTCCTTTCGCGCAGTACGTGGTTCGCGGCTTAATCCTGCTGGCAGCGGTGATCTTCGACCGTTACAAGCAAAAAGCGAAACGCACTGTCTGATGCTTTTTTCTGCAACAATTTAGCGTTTTTTCCCACCATAGCCAACCGCCATAACGGTTGGCTGTTCTTCGTTGCAAATGGCGACCCCCGTCACACTGTCTATACTTACATGTCTGTAAAGCGCGTTCTGCGCAACACAATAAGAAAAGAGAAGGAGGAGAACCGGgtgACAGAACCGTTAACCGAAACCCCTGAACTATCCGCGAAATATGCCTGGTTTTTTGATCTTGATGGAACGCTGGCGGAAATCAAACCGCATCCCGATCAGGTCGTCGTGCCTGACAATATTCTGCAAGGACTACAGCTACTGGCAACCGCAAGTGATGGTGCATTGGCATTGATATCAGGGCGCTCAATGGTGGAGCTTGACGCACTGGCAAAACCTTATCGCTTCCCGTtCTAGATTTAAGAAGGAGATATACATATGAGTAAAGGAGAAGAACTTTTCACTGGAGTTGTCCCAATTCTTGTTGAATTAGATGGTGATGTTAATGGGCACAAATTTTCTGTCAGTGGAGAGGGTGAAGGTGATGCTACATACGGAAAGCTTACCCTTAAATTTATTTGCACTACTGGAAAACTACCTGTTCCATGGCCAACACTTGTCACTACTTTGACCTATGGTGTTCAATGCTTTTCCCGTTATCCGGATCATATGAAACGGCATGACTTTTTCAAGAGTGCCATGCCCGAAGGTTATGTACAGGAACGCACTATATCTTTCAAAGATGACGGGAACTACAAGACGCGTGCTGAAGTCAAGTTTGAAGGTGATACCCTTGTTAATCGTATCGAGTTAAAAGGTATTGATTTTAAAGAAGATGGAAACATTCTCGGACACAAACTCGAGTACAACTATAACTCACACAATGTATACATCACGGCAGACAAACAAAAGAATGGAATCAAAGCTAACTTCAAAATTCGCCACAACATTGAAGATGGATCCGTTCAACTAGCAGACCATTATCAACAAAATACTCCAATTGGCGATGGCCCTGTCCTTTTACCAGACAACCATTACCTGTCGACACAATCTGCCCTTTCGAAAGATCCCAACGAAAAGCGTGACCACATGGTCCTTCTTGAGTTTGTAACTGCTGCTGGGATTACACATGGCATGGATGAGCTCTACAAATAATGAATTCCAGCTGAGCGCCGGTCGCTACCATTACCAGTTGGTCTGGTGTCAAAAATAATAATAACCGGGCAGGCCATGTCTGCCCGTATTTCGCGTAAGGAAATCCATTATGTACTATTTAATTCTTGAAGACGAAAGGGCCTCGTGATACGCCTATTTTTATAGGTTAATGTCATGATAATAATGGTTTCTTAGACGTCAGGTGGCGATATCGGGCTAGCCGGCCCGACGCACTTTGCGCCGAATAAATACCTGTGACGGAAGATCACTTCGCAGAATAAATAAATCCTGGTGTCCCTGTTGATACCGGGAAGCCCTGGGCCAACTTTTGGCGAAAATGAGACGTTGATCGGCACGTAAGAGGTTCCAACTTTCACCATAATGAAATAAGATCACTACCGGGCGTATTTTTTGAGTTATCGAGATTTTCAGGAGCTAAGGAAGCTAAAATGGAGAAAAAAATCACTGGATATACCACCGTTGATATATCCCAATGGCATCGTAAAGAACATTTTGAGGCATTTCAGTCAGTTGCTCAATGTACCTATAACCAGACCGTTCAGCTGGATATTACGGCCTTTTTAAAGACCGTAAAGAAAAATAAGCACAAGTTTTATCCGGCCTTTATTCACATTCTTGCCCGCCTGATGAATGCTCATCCGGAATTCCGTATGGCAATGAAAGACGGTGAGCTGGTGATATGGGATAGTGTTCACCCTTGTTACACCGTTTTCCATGAGCAAACTGAAACGTTTTCATCGCTCTGGAGTGAATACCACGACGATTTCCGGCAGTTTCTACACATATATTCGCAAGATGTGGCGTGTTACGGTGAAAACCTGGCCTATTTCCCTAAAGGGTTTATTGAGAATATGTTTTTCGTCTCAGCCAATCCCTGGGTGAGTTTCACCAGTTTTGATTTAAACGTGGCCAATATGGACAACTTCTTCGCCCCCGTTTTCACCATGGGCAAATATTATACGCAAGGCGACAAGGTGCTGATGCCGCTGGCGATTCAGGTTCATCATGCCGTCTGTGATGGCTTCCATGTCGGCAGAATGCTTAATGAATTACAACAGTACTGCGATGAGTGGCAGGGCGGGGCGTAATTTTTTTAAGGCAGTTATTGGTGCCCTTAAACGCCTGGTGCTACGCCTGAATAAGTGATAATAAGCGGATGAATGGCAGAAATGACGGATATCGTCCATTCCGACAGCATCGCCAGTCACTATGGCGTGCTGCTAGCGCTTTTAGCCGCTTTAGCGGCCTTTCCCCCTACCCGAAGGGTGGGGGCGCGTGTGCAGCCCCGCAGGGCCTGTCTCGGTCGATCATTCAGCCCGGCTCATCCTTCTGGCGTGGCGGCAGACCGAACAAGGCGCGGTCGTGGTCGCGTTCAAGGTACGCATCCATTGCCGCCATGAGCCGATCCTCCGGCCACTCGCTGCTGTTCACCTTGGCCAAAATCATGGCCCCCACCAGCACCTTGCGCCTTGTTTCGTTCTTGCGCTCTTGCTGCTGTTCCCTTGCCCGCACCCGCTGAATTTCGGCATTGATTCGCGCTCGTTGTTCTTCGAGCTTGGCCAGCCGATCCGCCGCCTTGTTGCTCCCCTTAACCATCTTGACACCCCATTGTTAATGTGCTGTCTCGTAGGCTATCATGGAGGCACAGCGGCGGCAATCCCGACCCTACTTTGTAGGGGAGGGCGCACTTACCGGTTTCTCTTCGAGAAACTGGCCTAACGGCCACCCTTCGGGCGGTGCGCTCTCCGAGGGCCATTGCATGGAGCCGAAAAGCAAAAGCAACAGCGAGGCAGCATGGCGATTTATCACCTTACGGCGAAAACCGGCAGCAGGTCGGGCGGCCAATCGGCCAGGGCCAAGGCCGACTACATCCAGCGCGAAGGCAAGTATGCCCGCGACATGGATGAAGTCTTGCACGCCGAATCCGGGCACATGCCGGAGTTCGTCGAGCGGCCCGCCGACTACTGGGATGCTGCCGACCTGTATGAACGCGCCAATGGGCGGCTGTTCAAGGAGGTCGAATTTGCCCTGCCGGTCGAGCTGACCCTCGACCAGCAGAAGGCGCTGGCGTCCGAGTTCGCCCAGCACCTGACCGGTGCCGAGCGCCTGCCGTATACGCTGGCCATCCATGCCGGTGGCGGCGAGAACCCGCACTGCCACCTGATGATCTCCGAGCGGATCAATGACGGCATCGAGCGGCCCGCCGCTCAGTGGTTCAAGCGGTACAACGGCAAGACCCCGGAGAAGGGCGGGGCACAGAAGACCGAAGCGCTCAAGCCCAAGGCATGGCTTGAGCAGACCCGCGAGGCATGGGCCGACCATGCCAACCGGGCATTAGAGCGGGCTGGCCACGACGCCCGCATTGACCACAGAACACTTGAGGCGCAGGGCATCGAGCGCCTGCCCGGTGTTCACCTGGGGCCGAACGTGGTGGAGATGGAAGGCCGGGGCATCCGCACCGACCGGGCAGACGTGGCCCTGAACATCGACACCGCCAACGCCCAGATCATCGACTTACAGGAATACCGGGAGGCAATAGACCATGAACGCAATCGACAGAGTGAAGAAATCCAGAGGCATCAACGAGTTAGCGGAGCAGATCGAACCGCTGGCCCAGAGCATGGCGACACTGGCCGACGAAGCCCGGCAGGTCATGAGCCAGACCCAGCAGGCCAGCGAGGCGCAGGCGGCGGAGTGGCTGAAAGCCCAGCGCCAGACAGGGGCGGCATGGGTGGAGCTGGCCAAAGAGTTGCGGGAGGTAGCCGCCGAGGTGAGCAGCGCCGCGCAGAGCGCCCGGAGCGCGTCGCGGGGGTGGCACTGGAAGCTATGGCTAACCGTGATGCTGGCTTCCATGATGCCTACGGTGGTGCTGCTGATCGCATCGTTGCTCTTGCTCGACCTGACGCCACTGACAACCGAGGACGGCTCGATCTGGCTGCGCTTGGTGGCCCGATGAAGAACGACAGGACTTTGCAGGCCATAGGCCGACAGCTCAAGGCCATGGGCTGTGAGCGCTCTTCCGCTTCCTCGCTCACTGACTCGCTGCGCTCGGTCGTTCGGCTGCGGCGAGCGGTATCAGCTCACTCAAAGGCGGTAATACGGTTATCCACAGAATCAGGGGATAACGCAGGAAAGAACATGTGAGCAAAAGGCCAGCAAAAGGCCAGGAACCGTAAAAAGGCCGCGTTGCTGGCGTTTTTCCATAGGCTCCGCCCCCCTGACGAGCATCACAAAAATCGACGCTCAAGTCAGAGGTGGCGAAACCCGACAGGACTATAAAGATACCAGGCGTTTCCCCCTGGAAGCTCCCTCGTGCGCTCTCCTGTTCCGACCCTGCCGCTTACCGGATACCTGTCCGCCTTTCTCCCTTCGGGAAGCGTGGCGCTTTCTCATAGCTCACGCTGTAGGTATCTCAGTTCGGTGTAGGTCGTTCGCTCCAAGCTGGGCTGTGTGCACGAACCCCCCGTTCAGCCCGACCGCTGCGCCTTATCCGGTAACTATCGTCTTGAGTCCAACCCGGTAAGACACGACTTATCGCCACTGGCAGCAGCCACTGGTAACAGGATTAGCAGAGCGAGGTATGTAGGCGGTGCTACAGAGTTCTTGAAGTGGTGGCCTAACTACGGCTACACTAGAAGGACAGTATTTGGTATCTGCGCTCTGCTGAAGCCAGTTACCTTCGGAAAAAGAGTTGGTAGCTCTTGATCCGGCAAACAAACCACCGCTGGTAGCGGTGGTTTTTTTGTTTGCAAGCAGCAGATTACGCGCAGAAAAAAAGGATCTCAAGAAGATCCTTTGATCTTTTCTACGGGGTCTGACGCTCAGTGGAACGAAAACTCACGTTAAGGGATTTTGGTCATGAGATTATCAAAAAGGATCTTCACCTAGATCCTTTTAAATTAAAAATGAAGTTTTAAATCAATCTAAAGTATATATGAGTAAACTTGGTCTGACAGTTACCAATGCTTAATCAGTGAGGCACCTATCTCAGCGATCTGTCTATTTCGTTCATCCATAGTTGCCTGACTCCCCGTCGTGTAGATAACTACGATACGGGAGGGCTTACCATCTGGCCCCAGTGCTGCAATGATACCGCGAGACCCACGCTCACCGGCTCCAGATTTATCAGCAATAAACCAGCCAGCCGGAAGGGCCGAGCGCAGAAGTGGTCCTGCAACTTTATCCGCCTCCATCCAGTCTATTAATTGTTGCCGGGAAGCTAGAGTAAGTAGTTCGCCAGTTAATAGTTTGCGCAACGTTGTTGCCATTGCTGCAGGCATCGTGGTGTCACGCTCGTCGTTTGGTATGGCTTCATTCAGCTCCGGTTCCCAACGATCAAGGCGAGTTACATGATCCCCCATGTTGTGCAAAAAAGCGGTTAGCTCCTTCGGTCCTCCGATCGTTGTCAGAAGTAAGTTGGCCGCAGTGTTATCACTCATGGTTATGGCAGCACTGCATAATTCTCTTACTGTCATGCCATCCGTAAGATGCTTTTCTGTGACTGGTGAGTACTCAACCAAGTCATTCTGAGAATAGTGTATGCGGCGACCGAGTTGCTCTTGCCCGGCGTCAACACGGGATAATACCGCGCCACATAGCAGAACTTTAAAAGTGCTCATCATTGGAAAACGTTCTTCGGGGCGAAAACTCTCAAGGATCTTACCGCTGTTGAGATCCAGTTCGATGTAACCCACTCGTGCACCCAACTGATCTTCAGCATCTTTTACTTTCACCAGCGTTTCTGGGTGAGCAAAAACAGGAAGGCAAAATGCCGCAAAAAAGGGAATAAGGGCGACACGGAAATGTTGAATACTCATACTCTTCCTTTTTCAATATTATTGAAGCATTTATCAGGGTTATTGTCTCATGAGCGGATACATATTTGAATGTATTTAGAAAAATAAACAAATAGGGGTTCCGCGCACATTTCCCCGAAAAGTGCCACCTGACGTCTAAGAAACCATTATTATCATGACATTAACCTATAAAAATAGGCGTATCACGAGGCCCTTTCGTCTTCAAGAA'
insertPlasmidSeq1 = 'GCTAAAGTTGGATACTTAAGAAATGCTTCATAATTCAGTAAGGCATTAGCATAATGGAAATAAAAGTGCAGAGACTATCTCTATGGATGATTAATACTGTCTTTTTATTGTCACCCATAAATAATCACCAGACTAATACTATCAACTTGATATTTGAAATGTGATCACTTGACTTTTGATACGTTATTTTATAACGGTTAACATATTTATAAAAACAACGGCCGTGCCACACGTCCGTTTCAATACTTAACGCACATGTATTTTGGTTTAGTCATCATCCGGTTATATGTATTTTAGCCAGGAACAGGTTAAATCATTCCTATATAACTCAAAAATTGAAACCTTATTCTCATGTCATGCTTATATTCATTATTATCGTTATATAAAAAGGCAACCATAATGTTTAGCAAATTGGCACAAAGTAGCATAAAGGCTATGTTTTAATTACAGGATGTTCAGTCATTTGAATGTATAACATTATAGCTAAACAAATCTAAAACGAAGTCAATAATTTATTGCTTTCACAAAATCTCATTTTGTTTAACATCCATTGAGATTCCTTGCTTTAAATTTTATTTTATATAAGCCATCATTTTAATTAATTTATTTTTTTGAGGGGGGGGTAATATACTCATATGCAAAATCAAGAAATAAACATCCTAATGAACCATATTAAATACCGTGGGATAAGACATAACAAatgAAGTGGATAGTAATTGACACGGTAATTCAACCTACATGTGGTATATCTTTTTCAGCCATATGGGGTAATATGAAAATGATCATCTGGTATCAATCTACTATATTTCTCCCTCCTGGCAGTATATTTACACCGGTTAAGTCTGGTATTATCCTTAAGGATAAAGAATATCCTATTACTATTTATCACATCGCACCATTCAACAAGGATTTATGGAGTTTACTCAAAAGCAGTCAAGAGTGTCCTCCAGGAGAAAGCAAAATAACAAATAAATGTTTACATAATAGTTGCATTATAAAAATATGCCCATATGGGCTCAAGtaa'
vectorSeq1 = 'CTAGATTTAAGAAGGAGATATACATATGAGTAAAGGAGAAGAACTTTTCACTGGAGTTGTCCCAATTCTTGTTGAATTAGATGGTGATGTTAATGGGCACAAATTTTCTGTCAGTGGAGAGGGTGAAGGTGATGCTACATACGGAAAGCTTACCCTTAAATTTATTTGCACTACTGGAAAACTACCTGTTCCATGGCCAACACTTGTCACTACTTTGACCTATGGTGTTCAATGCTTTTCCCGTTATCCGGATCATATGAAACGGCATGACTTTTTCAAGAGTGCCATGCCCGAAGGTTATGTACAGGAACGCACTATATCTTTCAAAGATGACGGGAACTACAAGACGCGTGCTGAAGTCAAGTTTGAAGGTGATACCCTTGTTAATCGTATCGAGTTAAAAGGTATTGATTTTAAAGAAGATGGAAACATTCTCGGACACAAACTCGAGTACAACTATAACTCACACAATGTATACATCACGGCAGACAAACAAAAGAATGGAATCAAAGCTAACTTCAAAATTCGCCACAACATTGAAGATGGATCCGTTCAACTAGCAGACCATTATCAACAAAATACTCCAATTGGCGATGGCCCTGTCCTTTTACCAGACAACCATTACCTGTCGACACAATCTGCCCTTTCGAAAGATCCCAACGAAAAGCGTGACCACATGGTCCTTCTTGAGTTTGTAACTGCTGCTGGGATTACACATGGCATGGATGAGCTCTACAAATAATGAATTCCAGCTGAGCGCCGGTCGCTACCATTACCAGTTGGTCTGGTGTCAAAAATAATAATAACCGGGCAGGCCATGTCTGCCCGTATTTCGCGTAAGGAAATCCATTATGTACTATTTAATTCTTGAAGACGAAAGGGCCTCGTGATACGCCTATTTTTATAGGTTAATGTCATGATAATAATGGTTTCTTAGACGTCAGGTGGCGATATCGGGCTAGCCGGCCCGACGCACTTTGCGCCGAATAAATACCTGTGACGGAAGATCACTTCGCAGAATAAATAAATCCTGGTGTCCCTGTTGATACCGGGAAGCCCTGGGCCAACTTTTGGCGAAAATGAGACGTTGATCGGCACGTAAGAGGTTCCAACTTTCACCATAATGAAATAAGATCACTACCGGGCGTATTTTTTGAGTTATCGAGATTTTCAGGAGCTAAGGAAGCTAAAATGGAGAAAAAAATCACTGGATATACCACCGTTGATATATCCCAATGGCATCGTAAAGAACATTTTGAGGCATTTCAGTCAGTTGCTCAATGTACCTATAACCAGACCGTTCAGCTGGATATTACGGCCTTTTTAAAGACCGTAAAGAAAAATAAGCACAAGTTTTATCCGGCCTTTATTCACATTCTTGCCCGCCTGATGAATGCTCATCCGGAATTCCGTATGGCAATGAAAGACGGTGAGCTGGTGATATGGGATAGTGTTCACCCTTGTTACACCGTTTTCCATGAGCAAACTGAAACGTTTTCATCGCTCTGGAGTGAATACCACGACGATTTCCGGCAGTTTCTACACATATATTCGCAAGATGTGGCGTGTTACGGTGAAAACCTGGCCTATTTCCCTAAAGGGTTTATTGAGAATATGTTTTTCGTCTCAGCCAATCCCTGGGTGAGTTTCACCAGTTTTGATTTAAACGTGGCCAATATGGACAACTTCTTCGCCCCCGTTTTCACCATGGGCAAATATTATACGCAAGGCGACAAGGTGCTGATGCCGCTGGCGATTCAGGTTCATCATGCCGTCTGTGATGGCTTCCATGTCGGCAGAATGCTTAATGAATTACAACAGTACTGCGATGAGTGGCAGGGCGGGGCGTAATTTTTTTAAGGCAGTTATTGGTGCCCTTAAACGCCTGGTGCTACGCCTGAATAAGTGATAATAAGCGGATGAATGGCAGAAATGACGGATATCGTCCATTCCGACAGCATCGCCAGTCACTATGGCGTGCTGCTAGCGCTTTTAGCCGCTTTAGCGGCCTTTCCCCCTACCCGAAGGGTGGGGGCGCGTGTGCAGCCCCGCAGGGCCTGTCTCGGTCGATCATTCAGCCCGGCTCATCCTTCTGGCGTGGCGGCAGACCGAACAAGGCGCGGTCGTGGTCGCGTTCAAGGTACGCATCCATTGCCGCCATGAGCCGATCCTCCGGCCACTCGCTGCTGTTCACCTTGGCCAAAATCATGGCCCCCACCAGCACCTTGCGCCTTGTTTCGTTCTTGCGCTCTTGCTGCTGTTCCCTTGCCCGCACCCGCTGAATTTCGGCATTGATTCGCGCTCGTTGTTCTTCGAGCTTGGCCAGCCGATCCGCCGCCTTGTTGCTCCCCTTAACCATCTTGACACCCCATTGTTAATGTGCTGTCTCGTAGGCTATCATGGAGGCACAGCGGCGGCAATCCCGACCCTACTTTGTAGGGGAGGGCGCACTTACCGGTTTCTCTTCGAGAAACTGGCCTAACGGCCACCCTTCGGGCGGTGCGCTCTCCGAGGGCCATTGCATGGAGCCGAAAAGCAAAAGCAACAGCGAGGCAGCATGGCGATTTATCACCTTACGGCGAAAACCGGCAGCAGGTCGGGCGGCCAATCGGCCAGGGCCAAGGCCGACTACATCCAGCGCGAAGGCAAGTATGCCCGCGACATGGATGAAGTCTTGCACGCCGAATCCGGGCACATGCCGGAGTTCGTCGAGCGGCCCGCCGACTACTGGGATGCTGCCGACCTGTATGAACGCGCCAATGGGCGGCTGTTCAAGGAGGTCGAATTTGCCCTGCCGGTCGAGCTGACCCTCGACCAGCAGAAGGCGCTGGCGTCCGAGTTCGCCCAGCACCTGACCGGTGCCGAGCGCCTGCCGTATACGCTGGCCATCCATGCCGGTGGCGGCGAGAACCCGCACTGCCACCTGATGATCTCCGAGCGGATCAATGACGGCATCGAGCGGCCCGCCGCTCAGTGGTTCAAGCGGTACAACGGCAAGACCCCGGAGAAGGGCGGGGCACAGAAGACCGAAGCGCTCAAGCCCAAGGCATGGCTTGAGCAGACCCGCGAGGCATGGGCCGACCATGCCAACCGGGCATTAGAGCGGGCTGGCCACGACGCCCGCATTGACCACAGAACACTTGAGGCGCAGGGCATCGAGCGCCTGCCCGGTGTTCACCTGGGGCCGAACGTGGTGGAGATGGAAGGCCGGGGCATCCGCACCGACCGGGCAGACGTGGCCCTGAACATCGACACCGCCAACGCCCAGATCATCGACTTACAGGAATACCGGGAGGCAATAGACCATGAACGCAATCGACAGAGTGAAGAAATCCAGAGGCATCAACGAGTTAGCGGAGCAGATCGAACCGCTGGCCCAGAGCATGGCGACACTGGCCGACGAAGCCCGGCAGGTCATGAGCCAGACCCAGCAGGCCAGCGAGGCGCAGGCGGCGGAGTGGCTGAAAGCCCAGCGCCAGACAGGGGCGGCATGGGTGGAGCTGGCCAAAGAGTTGCGGGAGGTAGCCGCCGAGGTGAGCAGCGCCGCGCAGAGCGCCCGGAGCGCGTCGCGGGGGTGGCACTGGAAGCTATGGCTAACCGTGATGCTGGCTTCCATGATGCCTACGGTGGTGCTGCTGATCGCATCGTTGCTCTTGCTCGACCTGACGCCACTGACAACCGAGGACGGCTCGATCTGGCTGCGCTTGGTGGCCCGATGAAGAACGACAGGACTTTGCAGGCCATAGGCCGACAGCTCAAGGCCATGGGCTGTGAGCGCTCTTCCGCTTCCTCGCTCACTGACTCGCTGCGCTCGGTCGTTCGGCTGCGGCGAGCGGTATCAGCTCACTCAAAGGCGGTAATACGGTTATCCACAGAATCAGGGGATAACGCAGGAAAGAACATGTGAGCAAAAGGCCAGCAAAAGGCCAGGAACCGTAAAAAGGCCGCGTTGCTGGCGTTTTTCCATAGGCTCCGCCCCCCTGACGAGCATCACAAAAATCGACGCTCAAGTCAGAGGTGGCGAAACCCGACAGGACTATAAAGATACCAGGCGTTTCCCCCTGGAAGCTCCCTCGTGCGCTCTCCTGTTCCGACCCTGCCGCTTACCGGATACCTGTCCGCCTTTCTCCCTTCGGGAAGCGTGGCGCTTTCTCATAGCTCACGCTGTAGGTATCTCAGTTCGGTGTAGGTCGTTCGCTCCAAGCTGGGCTGTGTGCACGAACCCCCCGTTCAGCCCGACCGCTGCGCCTTATCCGGTAACTATCGTCTTGAGTCCAACCCGGTAAGACACGACTTATCGCCACTGGCAGCAGCCACTGGTAACAGGATTAGCAGAGCGAGGTATGTAGGCGGTGCTACAGAGTTCTTGAAGTGGTGGCCTAACTACGGCTACACTAGAAGGACAGTATTTGGTATCTGCGCTCTGCTGAAGCCAGTTACCTTCGGAAAAAGAGTTGGTAGCTCTTGATCCGGCAAACAAACCACCGCTGGTAGCGGTGGTTTTTTTGTTTGCAAGCAGCAGATTACGCGCAGAAAAAAAGGATCTCAAGAAGATCCTTTGATCTTTTCTACGGGGTCTGACGCTCAGTGGAACGAAAACTCACGTTAAGGGATTTTGGTCATGAGATTATCAAAAAGGATCTTCACCTAGATCCTTTTAAATTAAAAATGAAGTTTTAAATCAATCTAAAGTATATATGAGTAAACTTGGTCTGACAGTTACCAATGCTTAATCAGTGAGGCACCTATCTCAGCGATCTGTCTATTTCGTTCATCCATAGTTGCCTGACTCCCCGTCGTGTAGATAACTACGATACGGGAGGGCTTACCATCTGGCCCCAGTGCTGCAATGATACCGCGAGACCCACGCTCACCGGCTCCAGATTTATCAGCAATAAACCAGCCAGCCGGAAGGGCCGAGCGCAGAAGTGGTCCTGCAACTTTATCCGCCTCCATCCAGTCTATTAATTGTTGCCGGGAAGCTAGAGTAAGTAGTTCGCCAGTTAATAGTTTGCGCAACGTTGTTGCCATTGCTGCAGGCATCGTGGTGTCACGCTCGTCGTTTGGTATGGCTTCATTCAGCTCCGGTTCCCAACGATCAAGGCGAGTTACATGATCCCCCATGTTGTGCAAAAAAGCGGTTAGCTCCTTCGGTCCTCCGATCGTTGTCAGAAGTAAGTTGGCCGCAGTGTTATCACTCATGGTTATGGCAGCACTGCATAATTCTCTTACTGTCATGCCATCCGTAAGATGCTTTTCTGTGACTGGTGAGTACTCAACCAAGTCATTCTGAGAATAGTGTATGCGGCGACCGAGTTGCTCTTGCCCGGCGTCAACACGGGATAATACCGCGCCACATAGCAGAACTTTAAAAGTGCTCATCATTGGAAAACGTTCTTCGGGGCGAAAACTCTCAAGGATCTTACCGCTGTTGAGATCCAGTTCGATGTAACCCACTCGTGCACCCAACTGATCTTCAGCATCTTTTACTTTCACCAGCGTTTCTGGGTGAGCAAAAACAGGAAGGCAAAATGCCGCAAAAAAGGGAATAAGGGCGACACGGAAATGTTGAATACTCATACTCTTCCTTTTTCAATATTATTGAAGCATTTATCAGGGTTATTGTCTCATGAGCGGATACATATTTGAATGTATTTAGAAAAATAAACAAATAGGGGTTCCGCGCACATTTCCCCGAAAAGTGCCACCTGACGTCTAAGAAACCATTATTATCATGACATTAACCTATAAAAATAGGCGTATCACGAGGCCCTTTCGTCTTCAAGAATTCGAGCTCGGTACCGGATCCGTCGACCTGCAGCCAAGCTTAATTAGCTGAGCTTGGACTCCTGTTGATAGATCCAGTAATGACCTCAGAACTCCATCTGGATTTGTTCAGAACGCTCGGTTGCCGCCGGGCGTTTTTTATTGGTGAGAATCCAAGCTAGCTTGGCGAGATTTTCAGGAGCTAAGGAAGCTAAAATGGAGAAAAAAATCACTGGATATACCACCGTTGATATATCCCAATGGCATCGTAAAGAACATTTTGAGGCATTTCAGTCAGTTGCTCAATGTACCTATAACCAGACCGTTCAGCTGGATATTACGGCCTTTTTAAAGACCGTAAAGAAAAATAAGCACAAGTTTTATCCGGCCTTTATTCACATTCTTGCCCGCCTGATGAATGCTCATCCGGAATTTCGTATGGCAATGAAAGACGGTGAGCTGGTGATATGGGATAGTGTTCACCCTTGTTACACCGTTTTCCATGAGCAAACTGAAACGTTTTCATCGCTCTGGAGTGAATACCACGACGATTTCCGGCAGTTTCTACACATATATTCGCAAGATGTGGCGTGTTACGGTGAAAACCTGGCCTATTTCCCTAAAGGGTTTATTGAGAATATGTTTTTCGTCTCAGCCAATCCCTGGGTGAGTTTCACCAGTTTTGATTTAAACGTGGCCAATATGGACAACTTCTTCGCCCCCGTTTTCACCATGGGCAAATATTATACGCAAGGCGACAAGGTGCTGATGCCGCTGGCGATTCAGGTTCATCATGCCGTTTGTGATGGCTTCCATGTCGGCAGAATGCTTAATGAATTACAACAGTACTGCGATGAGTGGCAGGGCGGGGCGTAATTTTTTTAAGGCAGTTATTGGTGCCCTTAAACGCCTGGGGTAATGACTCTCTAGCTTGAGGCATCAAATAAAACGAAAGGCTCAGTCGAAAGACTGGGCCTTTCGTTTTATCTGTTGTTTGTCGGTGAACGCTCTCCTGAGTAGGACAAATCCGCCCTCTAGCAGCCCGGGCTGC'
insertSeq1 = 'TCACTTGACTTTTGATACGTTATTTTATAACGGTTAACATATTTATAAAAACAACGGCCGTGCCACACGTCCGTTTCAATACTTAACGCACATGTATTTTGGTTTAGTCATCATCCGGTTATATGTATTTTAGCCAGGAACAGGTTAAATCATTCCTATATAACTCAAAAATTGAAACCTTATTCTCATGTCATGCTTATATTCATTATTATCGTTATATAAAAAGGCAACCATAATGTTTAGCAAATTGGCACAAAGTAGCATAAAGGCTATGTTTTAATTACAGGATGTTCAGTCATTTGAATGTATAACATTATAGCTAAACAAATCTAAAACGAAGTCAATAATTTATTGCTTTCACAAAATCTCATTTTGTTTAACATCCATTGAGATTCCTTGCTTTAAATTTTATTTTATATAAGCCATCATTTTAATTAATTTATTTTTTTGAGGGGGGGGTAATATACTCATATGCAAAATCAAGAAATAAACATCCTAATGAACCATATTAAATACCGTGGGATAAGACATAACAA'
vectorSeq1X = 'CTAGATTTAAGAAGGAGATATACATATGAGTAAAGGAGAAGAACTTTTCACTGGAGTTGTCCCAATTCTTGTTGAATTAGATGGTGATGTTAATGGGCACAAATTTTCTGTCAGTG'
insertSeq1X = 'TCACTTGACTTTTGATACGTTATTTTATAACGGTTAACATATTTATAAAAACAACGGCCGTGCCACACGTCCGTTTCAATACTTAACGCACATGTATTTTGGTTTAGTCATCATCCGGTTATATGTATTTTAGCCAGGAACAGGTTAAATCATTCCTATATAACTCAAAAATTGAAACCTTATTCTCATGTCATGCTTATATTCATTATTATCGTTATATAAAAAGGCAACCATAATGTTTAGCAAATTGGCACAAAGTAGCATAAAGG'
testOutput1 = 'ggccgcTATTTCTCCTTTCGCGCAGTACGTGGTTCGCGGCTTAATCCTGCTGGCAGCGGTGATCTTCGACCGTTACAAGCAAAAAGCGAAACGCACTGTCTGATGCTTTTTTCTGCAACAATTTAGCGTTTTTTCCCACCATAGCCAACCGCCATAACGGTTGGCTGTTCTTCGTTGCAAATGGCGACCCCCGTCACACTGTCTATACTTACATGTCTGTAAAGCGCGTTCTGCGCAACACAATAAGAAAACTAGATTTAAGAAGGAGATATACATATGAGTAAAGGAGAAGAACTTTTCACTGGAGTTGTCCCAATTCTTGTTGAATTAGATGGTGATGTTAATGGGCACAAATTTTCTGTCAGTGGAGAGGGTGAAGGTGATGCTACATACGGAAAGCTTACCCTTAAATTTATTTGCACTACTGGAAAACTACCTGTTCCATGGCCAACACTTGTCACTACTTTGACCTATGGTGTTCAATGCTTTTCCCGTTATCCGGATCATATGAAACGGCATGACTTTTTCAAGAGTGCCATGCCCGAAGGTTATGTACAGGAACGCACTATATCTTTCAAAGATGACGGGAACTACAAGACGCGTGCTGAAGTCAAGTTTGAAGGTGATACCCTTGTTAATCGTATCGAGTTAAAAGGTATTGATTTTAAAGAAGATGGAAACATTCTCGGACACAAACTCGAGTACAACTATAACTCACACAATGTATACATCACGGCAGACAAACAAAAGAATGGAATCAAAGCTAACTTCAAAATTCGCCACAACATTGAAGATGGATCCGTTCAACTAGCAGACCATTATCAACAAAATACTCCAATTGGCGATGGCCCTGTCCTTTTACCAGACAACCATTACCTGTCGACACAATCTGCCCTTTCGAAAGATCCCAACGAAAAGCGTGACCACATGGTCCTTCTTGAGTTTGTAACTGCTGCTGGGATTACACATGGCATGGATGAGCTCTACAAATAATGAATTCCAGCTGAGCGCCGGTCGCTACCATTACCAGTTGGTCTGGTGTCAAAAATAATAATAACCGGGCAGGCCATGTCTGCCCGTATTTCGCGTAAGGAAATCCATTATGTACTATTTAATTCTTGAAGACGAAAGGGCCTCGTGATACGCCTATTTTTATAGGTTAATGTCATGATAATAATGGTTTCTTAGACGTCAGGTGGCGATATCGGGCTAGCCGGCCCGACGCACTTTGCGCCGAATAAATACCTGTGACGGAAGATCACTTCGCAGAATAAATAAATCCTGGTGTCCCTGTTGATACCGGGAAGCCCTGGGCCAACTTTTGGCGAAAATGAGACGTTGATCGGCACGTAAGAGGTTCCAACTTTCACCATAATGAAATAAGATCACTACCGGGCGTATTTTTTGAGTTATCGAGATTTTCAGGAGCTAAGGAAGCTAAAATGGAGAAAAAAATCACTGGATATACCACCGTTGATATATCCCAATGGCATCGTAAAGAACATTTTGAGGCATTTCAGTCAGTTGCTCAATGTACCTATAACCAGACCGTTCAGCTGGATATTACGGCCTTTTTAAAGACCGTAAAGAAAAATAAGCACAAGTTTTATCCGGCCTTTATTCACATTCTTGCCCGCCTGATGAATGCTCATCCGGAATTCCGTATGGCAATGAAAGACGGTGAGCTGGTGATATGGGATAGTGTTCACCCTTGTTACACCGTTTTCCATGAGCAAACTGAAACGTTTTCATCGCTCTGGAGTGAATACCACGACGATTTCCGGCAGTTTCTACACATATATTCGCAAGATGTGGCGTGTTACGGTGAAAACCTGGCCTATTTCCCTAAAGGGTTTATTGAGAATATGTTTTTCGTCTCAGCCAATCCCTGGGTGAGTTTCACCAGTTTTGATTTAAACGTGGCCAATATGGACAACTTCTTCGCCCCCGTTTTCACCATGGGCAAATATTATACGCAAGGCGACAAGGTGCTGATGCCGCTGGCGATTCAGGTTCATCATGCCGTCTGTGATGGCTTCCATGTCGGCAGAATGCTTAATGAATTACAACAGTACTGCGATGAGTGGCAGGGCGGGGCGTAATTTTTTTAAGGCAGTTATTGGTGCCCTTAAACGCCTGGTGCTACGCCTGAATAAGTGATAATAAGCGGATGAATGGCAGAAATGACGGATATCGTCCATTCCGACAGCATCGCCAGTCACTATGGCGTGCTGCTAGCGCTTTTAGCCGCTTTAGCGGCCTTTCCCCCTACCCGAAGGGTGGGGGCGCGTGTGCAGCCCCGCAGGGCCTGTCTCGGTCGATCATTCAGCCCGGCTCATCCTTCTGGCGTGGCGGCAGACCGAACAAGGCGCGGTCGTGGTCGCGTTCAAGGTACGCATCCATTGCCGCCATGAGCCGATCCTCCGGCCACTCGCTGCTGTTCACCTTGGCCAAAATCATGGCCCCCACCAGCACCTTGCGCCTTGTTTCGTTCTTGCGCTCTTGCTGCTGTTCCCTTGCCCGCACCCGCTGAATTTCGGCATTGATTCGCGCTCGTTGTTCTTCGAGCTTGGCCAGCCGATCCGCCGCCTTGTTGCTCCCCTTAACCATCTTGACACCCCATTGTTAATGTGCTGTCTCGTAGGCTATCATGGAGGCACAGCGGCGGCAATCCCGACCCTACTTTGTAGGGGAGGGCGCACTTACCGGTTTCTCTTCGAGAAACTGGCCTAACGGCCACCCTTCGGGCGGTGCGCTCTCCGAGGGCCATTGCATGGAGCCGAAAAGCAAAAGCAACAGCGAGGCAGCATGGCGATTTATCACCTTACGGCGAAAACCGGCAGCAGGTCGGGCGGCCAATCGGCCAGGGCCAAGGCCGACTACATCCAGCGCGAAGGCAAGTATGCCCGCGACATGGATGAAGTCTTGCACGCCGAATCCGGGCACATGCCGGAGTTCGTCGAGCGGCCCGCCGACTACTGGGATGCTGCCGACCTGTATGAACGCGCCAATGGGCGGCTGTTCAAGGAGGTCGAATTTGCCCTGCCGGTCGAGCTGACCCTCGACCAGCAGAAGGCGCTGGCGTCCGAGTTCGCCCAGCACCTGACCGGTGCCGAGCGCCTGCCGTATACGCTGGCCATCCATGCCGGTGGCGGCGAGAACCCGCACTGCCACCTGATGATCTCCGAGCGGATCAATGACGGCATCGAGCGGCCCGCCGCTCAGTGGTTCAAGCGGTACAACGGCAAGACCCCGGAGAAGGGCGGGGCACAGAAGACCGAAGCGCTCAAGCCCAAGGCATGGCTTGAGCAGACCCGCGAGGCATGGGCCGACCATGCCAACCGGGCATTAGAGCGGGCTGGCCACGACGCCCGCATTGACCACAGAACACTTGAGGCGCAGGGCATCGAGCGCCTGCCCGGTGTTCACCTGGGGCCGAACGTGGTGGAGATGGAAGGCCGGGGCATCCGCACCGACCGGGCAGACGTGGCCCTGAACATCGACACCGCCAACGCCCAGATCATCGACTTACAGGAATACCGGGAGGCAATAGACCATGAACGCAATCGACAGAGTGAAGAAATCCAGAGGCATCAACGAGTTAGCGGAGCAGATCGAACCGCTGGCCCAGAGCATGGCGACACTGGCCGACGAAGCCCGGCAGGTCATGAGCCAGACCCAGCAGGCCAGCGAGGCGCAGGCGGCGGAGTGGCTGAAAGCCCAGCGCCAGACAGGGGCGGCATGGGTGGAGCTGGCCAAAGAGTTGCGGGAGGTAGCCGCCGAGGTGAGCAGCGCCGCGCAGAGCGCCCGGAGCGCGTCGCGGGGGTGGCACTGGAAGCTATGGCTAACCGTGATGCTGGCTTCCATGATGCCTACGGTGGTGCTGCTGATCGCATCGTTGCTCTTGCTCGACCTGACGCCACTGACAACCGAGGACGGCTCGATCTGGCTGCGCTTGGTGGCCCGATGAAGAACGACAGGACTTTGCAGGCCATAGGCCGACAGCTCAAGGCCATGGGCTGTGAGCGCTCTTCCGCTTCCTCGCTCACTGACTCGCTGCGCTCGGTCGTTCGGCTGCGGCGAGCGGTATCAGCTCACTCAAAGGCGGTAATACGGTTATCCACAGAATCAGGGGATAACGCAGGAAAGAACATGTGAGCAAAAGGCCAGCAAAAGGCCAGGAACCGTAAAAAGGCCGCGTTGCTGGCGTTTTTCCATAGGCTCCGCCCCCCTGACGAGCATCACAAAAATCGACGCTCAAGTCAGAGGTGGCGAAACCCGACAGGACTATAAAGATACCAGGCGTTTCCCCCTGGAAGCTCCCTCGTGCGCTCTCCTGTTCCGACCCTGCCGCTTACCGGATACCTGTCCGCCTTTCTCCCTTCGGGAAGCGTGGCGCTTTCTCATAGCTCACGCTGTAGGTATCTCAGTTCGGTGTAGGTCGTTCGCTCCAAGCTGGGCTGTGTGCACGAACCCCCCGTTCAGCCCGACCGCTGCGCCTTATCCGGTAACTATCGTCTTGAGTCCAACCCGGTAAGACACGACTTATCGCCACTGGCAGCAGCCACTGGTAACAGGATTAGCAGAGCGAGGTATGTAGGCGGTGCTACAGAGTTCTTGAAGTGGTGGCCTAACTACGGCTACACTAGAAGGACAGTATTTGGTATCTGCGCTCTGCTGAAGCCAGTTACCTTCGGAAAAAGAGTTGGTAGCTCTTGATCCGGCAAACAAACCACCGCTGGTAGCGGTGGTTTTTTTGTTTGCAAGCAGCAGATTACGCGCAGAAAAAAAGGATCTCAAGAAGATCCTTTGATCTTTTCTACGGGGTCTGACGCTCAGTGGAACGAAAACTCACGTTAAGGGATTTTGGTCATGAGATTATCAAAAAGGATCTTCACCTAGATCCTTTTAAATTAAAAATGAAGTTTTAAATCAATCTAAAGTATATATGAGTAAACTTGGTCTGACAGTTACCAATGCTTAATCAGTGAGGCACCTATCTCAGCGATCTGTCTATTTCGTTCATCCATAGTTGCCTGACTCCCCGTCGTGTAGATAACTACGATACGGGAGGGCTTACCATCTGGCCCCAGTGCTGCAATGATACCGCGAGACCCACGCTCACCGGCTCCAGATTTATCAGCAATAAACCAGCCAGCCGGAAGGGCCGAGCGCAGAAGTGGTCCTGCAACTTTATCCGCCTCCATCCAGTCTATTAATTGTTGCCGGGAAGCTAGAGTAAGTAGTTCGCCAGTTAATAGTTTGCGCAACGTTGTTGCCATTGCTGCAGGCATCGTGGTGTCACGCTCGTCGTTTGGTATGGCTTCATTCAGCTCCGGTTCCCAACGATCAAGGCGAGTTACATGATCCCCCATGTTGTGCAAAAAAGCGGTTAGCTCCTTCGGTCCTCCGATCGTTGTCAGAAGTAAGTTGGCCGCAGTGTTATCACTCATGGTTATGGCAGCACTGCATAATTCTCTTACTGTCATGCCATCCGTAAGATGCTTTTCTGTGACTGGTGAGTACTCAACCAAGTCATTCTGAGAATAGTGTATGCGGCGACCGAGTTGCTCTTGCCCGGCGTCAACACGGGATAATACCGCGCCACATAGCAGAACTTTAAAAGTGCTCATCATTGGAAAACGTTCTTCGGGGCGAAAACTCTCAAGGATCTTACCGCTGTTGAGATCCAGTTCGATGTAACCCACTCGTGCACCCAACTGATCTTCAGCATCTTTTACTTTCACCAGCGTTTCTGGGTGAGCAAAAACAGGAAGGCAAAATGCCGCAAAAAAGGGAATAAGGGCGACACGGAAATGTTGAATACTCATACTCTTCCTTTTTCAATATTATTGAAGCATTTATCAGGGTTATTGTCTCATGAGCGGATACATATTTGAATGTATTTAGAAAAATAAACAAATAGGGGTTCCGCGCACATTTCCCCGAAAAGTGCCACCTGACGTCTAAGAAACCATTATTATCATGACATTAACCTATAAAAATAGGCGTATCACGAGGCCCTTTCGTCTTCAAGAATTCGAGCTCGGTACCGGATCCGTCGACCTGCAGCCAAGCTTAATTAGCTGAGCTTGGACTCCTGTTGATAGATCCAGTAATGACCTCAGAACTCCATCTGGATTTGTTCAGAACGCTCGGTTGCCGCCGGGCGTTTTTTATTGGTGAGAATCCAAGCTAGCTTGGCGAGATTTTCAGGAGCTAAGGAAGCTAAAATGGAGAAAAAAATCACTGGATATACCACCGTTGATATATCCCAATGGCATCGTAAAGAACATTTTGAGGCATTTCAGTCAGTTGCTCAATGTACCTATAACCAGACCGTTCAGCTGGATATTACGGCCTTTTTAAAGACCGTAAAGAAAAATAAGCACAAGTTTTATCCGGCCTTTATTCACATTCTTGCCCGCCTGATGAATGCTCATCCGGAATTTCGTATGGCAATGAAAGACGGTGAGCTGGTGATATGGGATAGTGTTCACCCTTGTTACACCGTTTTCCATGAGCAAACTGAAACGTTTTCATCGCTCTGGAGTGAATACCACGACGATTTCCGGCAGTTTCTACACATATATTCGCAAGATGTGGCGTGTTACGGTGAAAACCTGGCCTATTTCCCTAAAGGGTTTATTGAGAATATGTTTTTCGTCTCAGCCAATCCCTGGGTGAGTTTCACCAGTTTTGATTTAAACGTGGCCAATATGGACAACTTCTTCGCCCCCGTTTTCACCATGGGCAAATATTATACGCAAGGCGACAAGGTGCTGATGCCGCTGGCGATTCAGGTTCATCATGCCGTTTGTGATGGCTTCCATGTCGGCAGAATGCTTAATGAATTACAACAGTACTGCGATGAGTGGCAGGGCGGGGCGTAATTTTTTTAAGGCAGTTATTGGTGCCCTTAAACGCCTGGGGTAATGACTCTCTAGCTTGAGGCATCAAATAAAACGAAAGGCTCAGTCGAAAGACTGGGCCTTTCGTTTTATCTGTTGTTTGTCGGTGAACGCTCTCCTGAGTAGGACAAATCCGCCCTCTAGCAGCCCGGGCTGCGAGAAGGAGGAGAACCGGgtgACAGAACCGTTAACCGAAACCCCTGAACTATCCGCGAAATATGCCTGGTTTTTTGATCTTGATGGAACGCTGGCGGAAATCAAACCGCATCCCGATCAGGTCGTCGTGCCTGACAATATTCTGCAAGGACTACAGCTACTGGCAACCGCAAGTGATGGTGCATTGGCATTGATATCAGGGCGCTCAATGGTGGAGCTTGACGCACTGGCAAAACCTTATCGCTTCCCGTt'

###################
### PARAMETERS ###
###################
# (copied from primer3 with subtle changes according to our first primer designed)
SEQUENCE_ID = 'MH1000'
PRIMER_OPT_TM = 59.0
PRIMER_MIN_TM = 50.0
PRIMER_MAX_TM = 70.0
PRIMER_PRODUCT_SIZE_RANGE = [[100, 300], [150, 250], [301, 400], [
    401, 500], [501, 600], [601, 700], [701, 850], [851, 1000]]
MAX_TEMP_DIFF = 7.0
PRIMER_MIN_SIZE = 18

###################
### WEBSCRAPING ###
###################


def primerDictToNEBPrimerSeq(primerDict):
    """turn a primer dict from primer3 in fastCloningPrimer to the NEB readdable format"""
    NEBPrimerString = ""
    for primerPairName, primerPairInfo in primerDict.items():
        currentLPrimerName = str(primerPairName) + "Left"
        currentLPrimerSeq = primerPairInfo[0][2]
        currentRPrimerName = str(primerPairName) + "Right"
        currentRPrimerSeq = primerPairInfo[1][2]
        NEBPrimerString += currentLPrimerName + "; " + currentLPrimerSeq + \
            "; " + currentRPrimerName + "; " + currentRPrimerSeq + "\n"
    return NEBPrimerString


def NEBWebscraper(primersSeq, phusionprimerOptTm):
    """Use NEB to check the melting temperature and annealing temperature of all primers"""
    # open the tm calculator headlessly
    options = webdriver.chrome.options.Options()
    # options.headless = True
    cwd = os.getcwd() + '/chromedriver'
    driver = webdriver.Chrome(options=options, executable_path=cwd)
    driver.get("https://tmcalculator.neb.com/#!/batch")

    time.sleep(1)

    # set the enzyme to phusion
    driver.find_element_by_xpath(
        "/html/body/div[3]/div[2]/div/div/div/div[2]/div[1]/form/div/div[1]/div/select[1]").send_keys("P\n")
    time.sleep(1)
    # set the primer input
    driver.find_element_by_id("batchinput").send_keys(
        primersSeq)

    # blur the focus to produce outputs
    driver.execute_script("document.getElementById('batchinput').blur()")

    # fetch the result table
    rows = driver.find_elements_by_css_selector(
        "table.batchresultstablex>tbody>tr")

    table = [[col.get_attribute("innerHTML").splitlines(
    ) for col in row.find_elements_by_css_selector("td")] for row in rows]

    # close the chrome driver
    # turn into a dictionary for easier manipulation
    NEBprimerDict = {}

    farthestTempDist = 0
    for primerIndex in range(len(table)):
        if primerIndex % 2 == 0:
            # left primer
            Lprimer = table[primerIndex]
            currentLPrimerName = Lprimer[0][0]
            currentLPrimerSeq = Lprimer[1][0][1:]
            currentLPrimerTm = Lprimer[2][0]
            currentLPrimerTa = float(Lprimer[3][0])

            # right primers
            Rprimer = table[primerIndex+1]
            currentRPrimerName = Rprimer[0][0]
            currentRPrimerSeq = Rprimer[1][0][1:]
            currentRPrimerTm = Rprimer[2][0]
            currentRPrimerTa = float(Rprimer[3][0])
            # primer pair name
            primerPairName = currentLPrimerName[:-4]
            phusionPrimerLowerBound = float(phusionprimerOptTm)-5
            phusionPrimerUpperBound = float(phusionprimerOptTm)+5
            if (currentLPrimerTa >= phusionPrimerLowerBound) and (currentLPrimerTa <= phusionPrimerUpperBound):
                if (currentRPrimerTa >= phusionPrimerLowerBound) and (currentRPrimerTa <= phusionPrimerUpperBound):
                    currentfarthestTempDist = max(abs(
                        currentLPrimerTa-phusionprimerOptTm), abs(currentRPrimerTa-phusionprimerOptTm))
                    NEBprimerDict.update(
                        {primerPairName: [['left', currentLPrimerTa, currentLPrimerSeq], ['right', currentRPrimerTa, currentRPrimerSeq]]})
                    if farthestTempDist < currentfarthestTempDist:
                        farthestTempDist = currentfarthestTempDist
    time.sleep(5)
    driver.close()
    return NEBprimerDict, farthestTempDist


###########################
### SEQUENCE PROCESSING ###
###########################


def fileParsing(vectorPlasmidAddress, insertPlasmidAddress):
    """Take in two addresses, one for vector plasmid and one for insert plasmid,
    turn into biopython seq objects"""
    if vectorPlasmidAddress[-5:] == 'fasta':
        vectorPlasmidSeq = SeqIO.read(vectorPlasmidAddress, "fasta").seq
        insertPlasmidSeq = SeqIO.read(insertPlasmidAddress, "fasta").seq
        return vectorPlasmidSeq, insertPlasmidSeq
    elif (vectorPlasmidAddress[-3:] == '.gb') or (vectorPlasmidAddress[-3:] == 'gbk'):
        vectorPlasmidSeq = SeqIO.read(vectorPlasmidAddress, "genbank").seq
        insertPlasmidSeq = SeqIO.read(insertPlasmidAddress, "genbank").seq
        return vectorPlasmidSeq, insertPlasmidSeq
    else:
        sys.exit('Unsupported file format.')
        return


# def pseudoCircularizePlasmid(plasmidSeq, goalSeq):
#     """Reorder (pseudo-circularize) a plasmid sequence so that it is essentially
#     still the same plasmid but contains the complete goalSeq. Note that there are two
#     scenarios:
#     (1) plasmidSeq = vectorPlasmidSeq; goalSeq = insertPlasmidSeq
#     (2) plasmidSeq = vectorSeq; goalSeq = insertSeq
#     We assume that the non-vector section will be longer than 2*17=34 bases.

#     The first output will be a pseudo-circularized DNA sequence which is essentially the same as
#     the input plasmidSeq, but will be prepared to be put into primer3. We also output the
#     starting and ending indexes of the goalSeq in the pseudo-circularized DNA sequence.
#     """
#     # 1. get two segments of goalSeq separated by lineared plasmid seq
#     finalPart1 = ''
#     finalPart2 = ''
#     for index in range(len(goalSeq)):
#         currentPart1 = goalSeq[0:index]
#         currentPart2 = goalSeq[index:]
#         if (currentPart1 in plasmidSeq) and (currentPart2 in plasmidSeq):
#             finalPart1 = currentPart1
#             finalPart2 = currentPart2
#             break
#     # 2. get the indexes of the two parts in the plasmid seq
#     part1StartInPlasmid = plasmidSeq.find(finalPart1)
#     part1EndInPlasmid = part1StartInPlasmid + len(finalPart1)
#     part2StartInPlasmid = plasmidSeq.find(finalPart2)
#     part2EndInPlasmid = part2StartInPlasmid + len(finalPart2)
#     # 3. generate pseudo-circularized plasmid
#     # 3.1 part 1 is at the end of the plasmid sequence
#     if part1EndInPlasmid == len(plasmidSeq):
#         nonVectorSegment = plasmidSeq[part2EndInPlasmid:part1StartInPlasmid]
#         arbitraryMiddleIndex = len(nonVectorSegment)//2
#         outputStart = arbitraryMiddleIndex
#         output = nonVectorSegment[:arbitraryMiddleIndex] + finalPart1 + \
#             finalPart2 + nonVectorSegment[arbitraryMiddleIndex:]
#     # 3.2 part 2 is at the end of the plasmid sequence
#     elif part2EndInPlasmid == len(plasmidSeq):
#         nonVectorSegment = plasmidSeq[part1EndInPlasmid:part2StartInPlasmid]
#         arbitraryMiddleIndex = len(nonVectorSegment)//2
#         outputStart = arbitraryMiddleIndex
#         # output = nonVectorSegment[:arbitraryMiddleIndex] + finalPart2 + \
#         #     finalPart1 + nonVectorSegment[arbitraryMiddleIndex:]
#     # 3.3 the plasmid sequence already contains the complete goalSeq
#     else:
#         output = plasmidSeq
#         outputStart = output.find(goalSeq)
#         outputEnd = outputStart + len(goalSeq)
#         nonVectorSegment = output[:outputStart] + output[outputEnd:]
#     # figure out the starting and ending indexes of goalSeq in the output sequence
#     # outputStart = output.find(goalSeq)
#     # outputEnd = outputStart + len(goalSeq)
#     # if part1EndInPlasmid != len(plasmidSeq) and part2EndInPlasmid != len(plasmidSeq):
#     #     nonVectorSegment = output[:outputStart] + output[outputEnd:]
#     return nonVectorSegment, outputStart

# #####################
# ### PRIMER DESIGN ###
# #####################


# def primer3ShortCut(seq, goalStart, primerOptTm=PRIMER_OPT_TM, primerMinSize=PRIMER_MIN_SIZE):
#     """Take in three outputs of pseudoCircularizePlasmid, call primer3 to create primers,
#     with parameters if needed"""
#     goalLen = len(seq)
#     # LEFT PRIMERS DESIGN: keep the right primers here
#     if primerOptTm != PRIMER_OPT_TM:
#         primerMinTm = primerOptTm-5
#         primerMaxTm = primerOptTm+5
#     else:
#         primerMinTm = PRIMER_MIN_TM
#         primerMaxTm = PRIMER_MAX_TM
#     sequenceMapL = {
#         'SEQUENCE_ID': SEQUENCE_ID,
#         'SEQUENCE_TEMPLATE': seq,
#         'SEQUENCE_INCLUDED_REGION': [goalStart-15, goalStart+25],
#     }
#     paramMapL = {
#         'PRIMER_OPT_TM': primerOptTm,
#         'PRIMER_MIN_TM': primerMinTm,
#         'PRIMER_MAX_TM': primerMaxTm,
#         'PRIMER_MIN_SIZE': primerMinSize,
#         # 'PRIMER_PRODUCT_SIZE_RANGE': [goalLen, goalLen+100],
#     }
#     leftPrimerInfo = primer3.bindings.designPrimers(sequenceMapL, paramMapL)
#     # RIGHT PRIMERS DESIGN: keep the left primers here
#     sequenceMapR = {
#         'SEQUENCE_ID': SEQUENCE_ID,
#         'SEQUENCE_TEMPLATE': seq,
#         'SEQUENCE_INCLUDED_REGION': [goalStart-25, goalStart+15],
#     }
#     paramMapR = {
#         'PRIMER_OPT_TM': primerOptTm,
#         'PRIMER_MIN_TM': primerMinTm,
#         'PRIMER_MAX_TM': primerMaxTm,
#         'PRIMER_MIN_SIZE': primerMinSize,
#         # 'PRIMER_PRODUCT_SIZE_RANGE': [goalLen, goalLen+100],
#     }
#     rightPrimerInfo = primer3.bindings.designPrimers(sequenceMapR, paramMapR)
#     return leftPrimerInfo, rightPrimerInfo


# def plasmidPrimerDesign(plasmidSeq, goalSeq, primerOptTm=PRIMER_OPT_TM, primerMinSize=PRIMER_MIN_SIZE):
#     """Uses the primer3-py api to find the primer info for isolating the current
#     goalSeq from the plasmidSeq"""
#     nonVectorSegment, goalSeqStart = pseudoCircularizePlasmid(
#         plasmidSeq, goalSeq)
#     leftPrimerInfo, rightPrimerInfo = primer3ShortCut(
#         nonVectorSegment, goalSeqStart, primerOptTm, primerMinSize)
#     return leftPrimerInfo, rightPrimerInfo

def pseudoCircularizePlasmid(plasmidSeq, goalSeq):
    """Reorder (pseudo-circularize) a plasmid sequence so that it is essentially
    still the same plasmid but contains the complete goalSeq. Note that there are two
    scenarios:
    (1) plasmidSeq = vectorPlasmidSeq; goalSeq = insertPlasmidSeq
    (2) plasmidSeq = vectorSeq; goalSeq = insertSeq
    We assume that the non-vector section will be longer than 2*17=34 bases.
    The first output will be a pseudo-circularized DNA sequence which is essentially the same as
    the input plasmidSeq, but will be prepared to be put into primer3. We also output the
    starting and ending indexes of the goalSeq in the pseudo-circularized DNA sequence.
    """
    # 1. get two segments of goalSeq separated by lineared plasmid seq
    finalPart1 = ''
    finalPart2 = ''
    for index in range(len(goalSeq)):
        currentPart1 = goalSeq[0:index]
        currentPart2 = goalSeq[index:]
        if (currentPart1 in plasmidSeq) and (currentPart2 in plasmidSeq):
            finalPart1 = currentPart1
            finalPart2 = currentPart2
            break
    # 2. get the indexes of the two parts in the plasmid seq
    part1StartInPlasmid = plasmidSeq.find(finalPart1)
    part1EndInPlasmid = part1StartInPlasmid + len(finalPart1)
    part2StartInPlasmid = plasmidSeq.find(finalPart2)
    part2EndInPlasmid = part2StartInPlasmid + len(finalPart2)
    # 3. generate pseudo-circularized plasmid
    # 3.1 part 1 is at the end of the plasmid sequence
    if part1EndInPlasmid == len(plasmidSeq):
        nonVectorSegment = plasmidSeq[part2EndInPlasmid:part1StartInPlasmid]
        arbitraryMiddleIndex = len(nonVectorSegment)//2
        output = nonVectorSegment[:arbitraryMiddleIndex] + finalPart1 + \
            finalPart2 + nonVectorSegment[arbitraryMiddleIndex:]
    # 3.2 part 2 is at the end of the plasmid sequence
    elif part2EndInPlasmid == len(plasmidSeq):
        nonVectorSegment = plasmidSeq[part1EndInPlasmid:part2StartInPlasmid]
        arbitraryMiddleIndex = len(nonVectorSegment)//2
        output = nonVectorSegment[:arbitraryMiddleIndex] + finalPart2 + \
            finalPart1 + nonVectorSegment[arbitraryMiddleIndex:]
    # 3.3 the plasmid sequence already contains the complete goalSeq
    else:
        output = plasmidSeq
    # figure out the starting and ending indexes of goalSeq in the output sequence
    outputStart = output.find(goalSeq)
    outputEnd = outputStart + len(goalSeq)
    return output, outputStart, outputEnd


def primer3ShortCut(seq, goalStart, goalEnd, primerOptTm=PRIMER_OPT_TM, primerMinTm=PRIMER_MIN_TM, primerMaxTm=PRIMER_MAX_TM, primerMinSize=PRIMER_MIN_SIZE):
    """Take in three outputs of pseudoCircularizePlasmid, call primer3 to create primers,
    with parameters if needed"""
    goalLen = goalEnd - goalStart
    print(goalStart)
    print(goalEnd)
    print(seq)
    LsequenceMap = {
        'SEQUENCE_ID': SEQUENCE_ID,
        'SEQUENCE_TEMPLATE': seq,
        # 'SEQUENCE_INCLUDED_REGION': [goalStart, goalEnd]
        'SEQUENCE_TARGET': [goalStart, goalStart+60]
        # 'SEQUENCE_PRIMER_PAIR_OK_REGION_LIST': [0, goalStart+15, goalEnd+16, 40]
    }
    LparamMap = {
        'PRIMER_OPT_TM': primerOptTm,
        'PRIMER_MIN_TM': primerMinTm,
        'PRIMER_MAX_TM': primerMaxTm,
        'PRIMER_MIN_SIZE': primerMinSize,
        'SEQUENCE_TARGET': [goalEnd-60, goalEnd]
        # 'PRIMER_PRODUCT_SIZE_RANGE': [goalLen, goalLen+100]
    }

    RsequenceMap = {
        'SEQUENCE_ID': SEQUENCE_ID,
        'SEQUENCE_TEMPLATE': seq,
        # 'SEQUENCE_INCLUDED_REGION': [goalStart, goalEnd]
        # 'SEQUENCE_TARGET': [goalStart, goalEnd]
        'SEQUENCE_PRIMER_PAIR_OK_REGION_LIST': [goalEnd-15, 100, goalEnd+101, 100]
    }
    RparamMap = {
        'PRIMER_OPT_TM': primerOptTm,
        'PRIMER_MIN_TM': primerMinTm,
        'PRIMER_MAX_TM': primerMaxTm,
        'PRIMER_MIN_SIZE': primerMinSize,
        # 'SEQUENCE_TARGET': [goalStart, goalEnd]
        # 'PRIMER_PRODUCT_SIZE_RANGE': [goalLen, goalLen+100]
    }
    return primer3.bindings.designPrimers(LsequenceMap, LparamMap), primer3.bindings.designPrimers(RsequenceMap, RparamMap)


def plasmidPrimerDesign(plasmidSeq, goalSeq):
    """Uses the primer3-py api to find the primer info for isolating the current
    goalSeq from the plasmidSeq"""
    preppedPlasmidSeq, goalSeqStart, goalSeqEnd = pseudoCircularizePlasmid(
        plasmidSeq, goalSeq)
    leftPrimerInfo, rightPrimerInfo = primer3ShortCut(
        preppedPlasmidSeq, goalSeqStart, goalSeqEnd)
    return leftPrimerInfo, rightPrimerInfo


def cleanPrimerInfo(leftPrimerInfo, rightPrimerInfo):
    """read primerInfo, the output of the previous function, and turn it into a more
    readable and analyzable data structure"""
    primerPairDict = {}
    leftPrimerL = []
    rightPrimerL = []
    for key in leftPrimerInfo:
        if key[-8:] == 'SEQUENCE' and key[:11] == 'PRIMER_LEFT':
            currentSequence = leftPrimerInfo[key]
            primerNum = key[12]
            if int(primerNum) <= 2:
                primerTM = rightPrimerInfo[key[:13]+'_TM']
                rightPrimerL.append(
                    ['rightPrimer'+str(primerNum), primerTM, currentSequence])

    for key in rightPrimerInfo:
        if key[-8:] == 'SEQUENCE' and key[:12] == 'PRIMER_RIGHT':
            currentSequence = leftPrimerInfo[key]
            primerNum = key[13]
            if int(primerNum) <= 2:
                primerTM = leftPrimerInfo[key[:14]+'_TM']
                leftPrimerL.append(
                    ['leftPrimer'+str(primerNum), primerTM, currentSequence])

    # update resultant dict
    primerPairNum = 0
    for leftPrimer in leftPrimerL:
        for rightPrimer in rightPrimerL:
            primerPairNum += 1
            primerPairKey = "primerPair" + str(primerPairNum)
            leftPrimerCopy = copy.deepcopy(leftPrimer)
            leftPrimerCopy[0] = 'leftPrimer' + str(primerPairNum)
            rightPrimerCopy = copy.deepcopy(rightPrimer)
            rightPrimerCopy[0] = 'rightPrimer' + str(primerPairNum)
            primerPairDict.update(
                {primerPairKey: [leftPrimerCopy, rightPrimerCopy]})
    return primerPairDict


def primer3Only(plasmidSeq, goalSeq, primerOptTm=PRIMER_OPT_TM, primerMinSize=PRIMER_MIN_SIZE):
    """A quick wrapper for non-fastCloning specific primer design"""
    primerInfo = plasmidPrimerDesign(
        plasmidSeq, goalSeq, primerOptTm, primerMinSize)
    print('  _________\n /         \\\n |  /\\ /\\  |\n |    -    |\n |  \\___/  |\n \\_________/')
    print('PROCESSING')
    print('author: Tom Fu, Richard Chang; HMC BioMakerspace')
    return cleanPrimerInfo(primerInfo)


def tempDiffRestrict(primerInfo, maxTempDiff=MAX_TEMP_DIFF):
    """Checks the differnce in annealing temperatures between two primers.
       Difference should not be greater than 5 degrees."""
    for key in primerInfo.copy():
        if abs(primerInfo[key][0][1] - primerInfo[key][1][1]) > maxTempDiff:
            del primerInfo[key]
    return primerInfo


def TaqvectorPrimerDesign(vectorPlasmidSeq, vectorSeq, maxTempDiff=MAX_TEMP_DIFF, primerOptTm=PRIMER_OPT_TM, primerMinSize=PRIMER_MIN_SIZE):
    """Find the primers isolating vectorSeq from vectorPlasmidSeq; meanwhile
    getting two overhang sequences that need to be attached to the insert primer
    pairs"""
    cleanedPrimerInfo = primer3Only(
        vectorPlasmidSeq, vectorSeq, primerOptTm, primerMinSize)
    rightTempPrimerInfo = tempDiffRestrict(cleanedPrimerInfo, maxTempDiff)
    for key, val in rightTempPrimerInfo.copy().items():
        currentLeftPrimer = val[0][2]
        currentRightPrimer = val[1][2]
        if (len(currentLeftPrimer) >= 18) and (len(currentRightPrimer) >= 18):
            leftOverHang = currentLeftPrimer[:16]
            rightOverHang = currentRightPrimer[:16]
            val[0].append(leftOverHang)
            val[1].append(rightOverHang)
        else:
            sys.exit(
                "The following primer pair is not long enough for FastCloning, thus removed", str(val))
    return rightTempPrimerInfo


def TaqinsertPrimerDesign(rightTempVectorPrimerInfoWOverhang, insertPlasmidSeq, insertSeq, maxTempDiff=MAX_TEMP_DIFF, primerOptTm=PRIMER_OPT_TM, primerMinSize=PRIMER_MIN_SIZE):
    """Find the primers isolating insertSeq from insertPlasmidSeq; meanwhile attaching
    the two overhang sequences to the insert primer pairs"""
    cleanedInsertPrimerInfo = primer3Only(
        insertPlasmidSeq, insertSeq, primerOptTm, primerMinSize)
    rightTempInsertPrimerInfo = tempDiffRestrict(
        cleanedInsertPrimerInfo, maxTempDiff)
    outputDict = {}
    outputL = []
    primer4Num = 1
    for vkey, currentVPrimerPair in rightTempVectorPrimerInfoWOverhang.items():
        for ikey, currentIPrimerPair in rightTempInsertPrimerInfo.items():
            # vector primers
            vcurrentLSeq = currentVPrimerPair[0][2]
            vcurrentLTemp = currentVPrimerPair[0][1]
            vcurrentLOverhang = currentVPrimerPair[0][3]
            vcurrentRSeq = currentVPrimerPair[1][2]
            vcurrentRTemp = currentVPrimerPair[1][1]
            vcurrentROverhang = currentVPrimerPair[1][3]
            # insert primers
            icurrentLSeq = currentIPrimerPair[0][2]
            icurrentLTemp = currentIPrimerPair[0][1]
            icurrentRSeq = currentIPrimerPair[1][2]
            icurrentRTemp = currentIPrimerPair[1][1]
            # attach the left overhang to right iprimers and vice versa
            newiCurrentLSeq = vcurrentROverhang.lower() + icurrentLSeq
            newiCurrentRSeq = vcurrentLOverhang.lower() + icurrentRSeq
            # save current info
            outputDict.update(
                {('vectorLeftPrimer' + str(primer4Num)): [vcurrentLTemp, vcurrentLSeq]})
            outputDict.update(
                {('vectorRightPrimer' + str(primer4Num)): [vcurrentRTemp, vcurrentRSeq]})
            outputDict.update(
                {('insertLeftPrimer' + str(primer4Num)): [icurrentLTemp, newiCurrentLSeq]})
            outputDict.update(
                {('insertRightPrimer' + str(primer4Num)): [icurrentRTemp, newiCurrentRSeq]})
            outputL.append(
                [('vectorLeftPrimer' + str(primer4Num)), vcurrentLTemp, vcurrentLSeq])
            outputL.append(
                [('vectorRightPrimer' + str(primer4Num)), vcurrentRTemp, vcurrentRSeq])
            outputL.append(
                [('insertLeftPrimer' + str(primer4Num)), icurrentLTemp, newiCurrentLSeq])
            outputL.append(
                [('insertRightPrimer' + str(primer4Num)), icurrentRTemp, newiCurrentRSeq])
            primer4Num += 1
    return outputDict, outputL


def vectorPrimerDesign(vectorPlasmidSeq, vectorSeq, maxTempDiff=MAX_TEMP_DIFF, primerOptTm=PRIMER_OPT_TM, primerMinSize=PRIMER_MIN_SIZE):
    """Find the primers isolating vectorSeq from vectorPlasmidSeq; meanwhile
    getting two overhang sequences that need to be attached to the insert primer
    pairs"""
    currentLen = 0
    rightTempPrimerInfo = {}
    bestFarthestTempDist = float("inf")
    # for value in range(-5, -3):
    for value in range(-3, 3):
        print("VECTOR")
        print(value)
        cleanedPrimerInfo = primer3Only(
            vectorPlasmidSeq, vectorSeq, primerOptTm+value, primerMinSize)
        temprightTempPrimerInfo = tempDiffRestrict(
            cleanedPrimerInfo, maxTempDiff)
        # check phusion for temperature
        primerSeqNEB = primerDictToNEBPrimerSeq(
            temprightTempPrimerInfo)
        temprightTempPrimerInfo, currentfarthestTempDist = NEBWebscraper(
            primerSeqNEB, primerOptTm)
        if temprightTempPrimerInfo != {}:
            if bestFarthestTempDist > currentfarthestTempDist or len(temprightTempPrimerInfo) > currentLen:
                bestFarthestTempDist = currentfarthestTempDist
                print(bestFarthestTempDist)
                rightTempPrimerInfo = temprightTempPrimerInfo
                currentLen = len(rightTempPrimerInfo)
                print("UPDATE")
                print(rightTempPrimerInfo)
    # go on and find overhang
    # rightTempPrimerInfoNoOverhang = copy.deepcopy(rightTempPrimerInfo)
    rightTempPrimerInfoOverhang = rightTempPrimerInfo.copy()
    for key, val in rightTempPrimerInfo.items():
        currentLeftPrimer = val[0][2]
        currentRightPrimer = val[1][2]
        if (len(currentLeftPrimer) >= 18) and (len(currentRightPrimer) >= 18):
            leftOverHang = currentLeftPrimer[:16]
            rightOverHang = currentRightPrimer[:16]
            val[0].append(leftOverHang)
            val[1].append(rightOverHang)
        else:
            sys.exit(
                "The following primer pair is not long enough for FastCloning, thus removed", str(val))
    print(rightTempPrimerInfoOverhang)
    return rightTempPrimerInfoOverhang
    # elif enzyme == "phusion":

    # return rightTempPrimerInfo


def insertPrimerDesign(rightTempVectorPrimerInfoWOverhang, insertPlasmidSeq, insertSeq, maxTempDiff=MAX_TEMP_DIFF, primerOptTm=PRIMER_OPT_TM, primerMinSize=PRIMER_MIN_SIZE):
    """Find the primers isolating insertSeq from insertPlasmidSeq; meanwhile attaching
    the two overhang sequences to the insert primer pairs"""
    currentLen = 0
    rightTempInsertPrimerInfo = {}
    bestFarthestTempDist = float("inf")
    for value in range(-3, 3):
        # for value in range(-5, 6):
        print("INSERT")
        print(value)
        cleanedPrimerInfo = primer3Only(
            insertPlasmidSeq, insertSeq, primerOptTm+value, primerMinSize)
        temprightTempPrimerInfo = tempDiffRestrict(
            cleanedPrimerInfo, maxTempDiff)
        # check phusion for temperature
        primerSeqNEB = primerDictToNEBPrimerSeq(
            temprightTempPrimerInfo)
        temprightTempPrimerInfo, currentfarthestTempDist = NEBWebscraper(
            primerSeqNEB, primerOptTm)
        if temprightTempPrimerInfo != {}:
            if bestFarthestTempDist > currentfarthestTempDist or len(temprightTempPrimerInfo) > currentLen:
                bestFarthestTempDist = currentfarthestTempDist
                print(bestFarthestTempDist)
                rightTempInsertPrimerInfo = temprightTempPrimerInfo
                currentLen = len(rightTempInsertPrimerInfo)
                print("UPDATE")
                print(rightTempInsertPrimerInfo)
    # go on
    outputDict = {}
    outputL = []
    primer4Num = 1
    for vkey, currentVPrimerPair in rightTempVectorPrimerInfoWOverhang.items():
        for ikey, currentIPrimerPair in rightTempInsertPrimerInfo.items():
            # vector primers
            vcurrentLSeq = currentVPrimerPair[0][2]
            vcurrentLTemp = currentVPrimerPair[0][1]
            vcurrentLOverhang = currentVPrimerPair[0][3]
            vcurrentRSeq = currentVPrimerPair[1][2]
            vcurrentRTemp = currentVPrimerPair[1][1]
            vcurrentROverhang = currentVPrimerPair[1][3]
            # insert primers
            icurrentLSeq = currentIPrimerPair[0][2]
            icurrentLTemp = currentIPrimerPair[0][1]
            icurrentRSeq = currentIPrimerPair[1][2]
            icurrentRTemp = currentIPrimerPair[1][1]
            # attach the left overhang to right iprimers and vice versa
            newiCurrentLSeq = vcurrentROverhang.lower() + icurrentLSeq
            newiCurrentRSeq = vcurrentLOverhang.lower() + icurrentRSeq
            # save current info
            outputDict.update(
                {('vectorLeftPrimer' + str(primer4Num)): [vcurrentLTemp, vcurrentLSeq]})
            outputDict.update(
                {('vectorRightPrimer' + str(primer4Num)): [vcurrentRTemp, vcurrentRSeq]})
            outputDict.update(
                {('insertLeftPrimer' + str(primer4Num)): [icurrentLTemp, newiCurrentLSeq]})
            outputDict.update(
                {('insertRightPrimer' + str(primer4Num)): [icurrentRTemp, newiCurrentRSeq]})
            outputL.append(
                [('vectorLeftPrimer' + str(primer4Num)), vcurrentLTemp, vcurrentLSeq])
            outputL.append(
                [('vectorRightPrimer' + str(primer4Num)), vcurrentRTemp, vcurrentRSeq])
            outputL.append(
                [('insertLeftPrimer' + str(primer4Num)), icurrentLTemp, newiCurrentLSeq])
            outputL.append(
                [('insertRightPrimer' + str(primer4Num)), icurrentRTemp, newiCurrentRSeq])
            primer4Num += 1
    return outputDict, outputL

# WRAPPER FUNCTIONS


def plasmidPrimers(plasmidSeq, goalSeq, benchling=True, destinationAddress='plasmidPrimerInfo.csv', benchlingAddress='benchlingPlasmidPrimerInfo.csv', primerOptTm=PRIMER_OPT_TM, primerMinSize=PRIMER_MIN_SIZE, enzyme="Taq", maxTempDiff=MAX_TEMP_DIFF):

    # Use NEB to check temp
    if enzyme == "Taq":
        primersDict = primer3Only(
            plasmidSeq, goalSeq, primerOptTm, primerMinSize)
        tempString = "meltingTemp (in degree C)"
    elif enzyme == "phusion":
        tempString = 'annealingTemp (in degree C)'
        currentLen = 0
        primersDict = {}
        bestFarthestTempDist = float("inf")
        for value in range(-3, 3):
            cleanedPrimerInfo = primer3Only(
                plasmidSeq, goalSeq, primerOptTm+value, primerMinSize)
            temprightTempPrimerInfo = tempDiffRestrict(
                cleanedPrimerInfo, maxTempDiff)
            # check phusion for temperature
            primerSeqNEB = primerDictToNEBPrimerSeq(
                temprightTempPrimerInfo)
            print(primerSeqNEB)
            temprightTempPrimerInfo, currentfarthestTempDist = NEBWebscraper(
                primerSeqNEB, primerOptTm)
            print(currentfarthestTempDist)
            if temprightTempPrimerInfo != {}:
                if bestFarthestTempDist > currentfarthestTempDist or len(temprightTempPrimerInfo) > currentLen:
                    bestFarthestTempDist = currentfarthestTempDist
                    print(bestFarthestTempDist)
                    currentLen = len(temprightTempPrimerInfo)
                    primersDict = temprightTempPrimerInfo
                    print(temprightTempPrimerInfo)
    print("FinalPrimersDict")
    print(primersDict)
    # go on
    outputL = []
    primerPairNum = 1
    for key, currentPrimerPair in primersDict.items():
        currentLeftPrimerSeq = currentPrimerPair[0][2]
        currentLeftPrimerTemp = currentPrimerPair[0][1]
        currentRightPrimerSeq = currentPrimerPair[1][2]
        currentRightPrimerTemp = currentPrimerPair[1][1]
        outputL.append([('leftPrimer' + str(primerPairNum)),
                        currentLeftPrimerTemp, currentLeftPrimerSeq])
        outputL.append([('rightPrimer' + str(primerPairNum)),
                        currentRightPrimerTemp, currentRightPrimerSeq])
        primerPairNum += 1
    currentDF = pd.DataFrame(
        outputL, columns=['primerInfo', tempString, 'sequence'])
    currentDF.to_csv(destinationAddress)
    print("Check out the following file for your primers:")
    print(destinationAddress)
    if benchling == True:
        benchlingL = [[currentPrimer[0], currentPrimer[2]]
                      for currentPrimer in outputL]
        benchlingDF = pd.DataFrame(
            benchlingL)
        benchlingDF.to_csv(benchlingAddress, index=False)
        print("Your benchling-ready csv file is:")
        print('benchling'+destinationAddress)
    return


def plasmidPrimersFile(plasmidSeqFile, goalSeq, benchling=True, destinationAddress='plasmidPrimerInfo.csv', benchlingAddress='benchlingPlasmidPrimerInfo.csv', primerOptTm=PRIMER_OPT_TM, primerMinSize=PRIMER_MIN_SIZE, enzyme="Taq"):
    if plasmidSeqFile[-5:] == 'fasta':
        plasmidSeq = str(SeqIO.read(plasmidSeqFile, "fasta").seq)
    elif (plasmidSeqFile[-3:] == '.gb') or (plasmidSeqFile[-3:] == 'gbk'):
        plasmidSeq = str(SeqIO.read(plasmidSeqFile, "genbank").seq)
    else:
        sys.exit('Unsupported file format.')
    return plasmidPrimers(plasmidSeq, goalSeq, benchling, destinationAddress, benchlingAddress, primerOptTm, primerMinSize, enzyme)


def fastCloningPrimers(vectorPlasmidSeq, insertPlasmidSeq, vectorSeq, insertSeq, maxTempDiff=MAX_TEMP_DIFF, destinationAddress='fastCloningPrimerInfo.csv', benchlingAddress='benchlingfastCloningPrimerInfo.csv', benchling=True, primerOptTm=PRIMER_OPT_TM, primerMinSize=PRIMER_MIN_SIZE, enzyme="phusion"):
    """Wrapper function that generates 2 primer pairs for the given circular
    raw vector and insert sequences

    Args:
        vectorPlasmidSeq ([str]): vector plasmid
        insertPlasmidSeq ([str]): insert plasmid
        vectorSeq ([str]): vector sequence
        insertSeq ([str]): insert sequence
    """
    if enzyme == "phusion":
        rightTempVectorPrimerInfoWOverhang = vectorPrimerDesign(
            vectorPlasmidSeq, vectorSeq, maxTempDiff, primerOptTm, primerMinSize)
        outputDict, outputL = insertPrimerDesign(
            rightTempVectorPrimerInfoWOverhang, insertPlasmidSeq, insertSeq, maxTempDiff, primerOptTm,  primerMinSize)
        currentDF = pd.DataFrame(
            outputL, columns=['primerInfo', 'annealingTemp (in degree C)', 'sequence'])
        currentDF.to_csv(destinationAddress)
        print("Check out the following file for your primers:")
        print(destinationAddress)
        if benchling == True:
            benchlingL = [[currentPrimer[0], currentPrimer[2]]
                          for currentPrimer in outputL]
            benchlingDF = pd.DataFrame(
                benchlingL)
            benchlingDF.to_csv(benchlingAddress, index=False)
            print("Your benchling-ready csv file is:")
            print(benchlingAddress)
    elif enzyme == "Taq":
        rightTempVectorPrimerInfoWOverhang = TaqvectorPrimerDesign(
            vectorPlasmidSeq, vectorSeq, maxTempDiff, primerOptTm, primerMinSize)
        outputDict, outputL = TaqinsertPrimerDesign(
            rightTempVectorPrimerInfoWOverhang, insertPlasmidSeq, insertSeq, maxTempDiff, primerOptTm,  primerMinSize)
        currentDF = pd.DataFrame(
            outputL, columns=['primerInfo', 'annealingTemp (in degree C)', 'sequence'])
        currentDF.to_csv(destinationAddress)
        print("Check out the following file for your primers:")
        print(destinationAddress)
        if benchling == True:
            benchlingL = [[currentPrimer[0], currentPrimer[2]]
                          for currentPrimer in outputL]
            benchlingDF = pd.DataFrame(
                benchlingL)
            benchlingDF.to_csv(benchlingAddress, index=False)
            print("Your benchling-ready csv file is:")
            print(benchlingAddress)
    return


def fastCloningPrimersFile(vectorPlasmidAddress, insertPlasmidAddress, vectorSeq, insertSeq, maxTempDiff=MAX_TEMP_DIFF, destinationAddress='fastCloningPrimerInfo.csv', benchlingAddress='benchlingfastCloningPrimerInfo.csv', benchling=True, primerOptTm=PRIMER_OPT_TM, primerMinSize=PRIMER_MIN_SIZE, enzyme="phusion"):
    """Wrapper function that generates 2 primer pairs for the given circular
    raw vector and insert sequences given fasta/gb files

    Args:
        vectorPlasmidAddress ([str]): address for vector plasmid
        insertPlasmidAddress ([str]): address for insert plasmid
        vectorSeq ([str]): vector sequence
        insertSeq ([str]): insert sequence
    """
    vectorPlasmidSeq, insertPlasmidSeq = fileParsing(
        vectorPlasmidAddress, insertPlasmidAddress)
    vectorPlasmidSeq = str(vectorPlasmidSeq)
    insertPlasmidSeq = str(insertPlasmidSeq)
    return fastCloningPrimers(vectorPlasmidSeq, insertPlasmidSeq, vectorSeq, insertSeq, maxTempDiff, destinationAddress, benchlingAddress, benchling, primerOptTm,   primerMinSize, enzyme)
